package configs

import (
	"errors"
	"gopkg.in/yaml.v2"
	"main/global"
	. "main/utils"
	"main/writers"
	"os"
	"path"
)

var conf *Config
var nodeCurrentReplicasVec [][]nodeCurrentReplicas
var commandsConf []*CommandsConf
var clusterKubeconfigPaths []string
var ClusterKubeconfigs []*KubeConfig
var none = None[global.LogCommandInfo]()

// KubeConfig struct is to keep track of all the contexts
// from autogenerated and user-provided kubeconfig and their
// associated cluster to switch clusters seamlessly
type KubeConfig struct {
	Contexts []Context     `yaml:"contexts"`
	Clusters []KubeCluster `yaml:"clusters"`
}

type KubeCluster struct {
	Name string `yaml:"name"`
}

type Context struct {
	ContextInfo  ContextInfo `yaml:"context"`
	Name         string      `yaml:"name"`
	ClusterIndex int
}

type ContextInfo struct {
	Cluster string `yaml:"cluster"`
}

// Kube struct is for wrapped commands who
// want to perform operations through kubectl
type Kube struct {
	Filename string
	Args     []string
	Count    int
}

type Cluster struct {
	ClusterName string   `yaml:"clusterName"`
	KwokConfigs []string `yaml:"kwokConfigs"`
	Nodes       []Node   `yaml:"nodes"`
	Audit       string   `yaml:"auditLoggingConfig"`
	Commands    string   `yaml:"commandsConfig"`
}

type LiqoOffload struct {
	Namespace         string   `yaml:"namespace"`
	ClusterSelector   []string `yaml:"clusterSelector"`   // Default: empty
	NamespaceStrategy string   `yaml:"namespaceStrategy"` // Default: DefaultName
	PodStrategy       string   `yaml:"podStrategy"`       // Default: LocalAndRemote
	RuntimeClass      string   `yaml:"runtimeClass"`      // Default: empty
}

type LiqoOpt struct {
	Consumer string        `yaml:"consumer"`
	Offload  []LiqoOffload `yaml:"offload,omitempty"`
}

// Config struct contains all the data in
// the main config file about the topology of the cluster(s)
type Config struct {
	Liqo              LiqoOpt
	Clusters          []Cluster `yaml:"clusters"`
	LiqoConsumerIndex int
}

// Command struct contains a single command of the
// command sequence inside a Queue
type Command struct {
	Exec     string   `yaml:"exec,omitempty"`
	Command  string   `yaml:"command,omitempty"`
	Time     float64  `yaml:"time"`
	Filename string   `yaml:"filename,omitempty"`
	Count    int      `yaml:"count,omitempty"`
	Args     []string `yaml:"args,omitempty"`
	Context  string   `yaml:"context,omitempty"`
	index    int
}

// Queue struct contains a Command sequence and the
// data of the Queue
type Queue struct {
	Name        string    `yaml:"name"`
	Kubeconfig  string    `yaml:"kubeconfig"`
	Sequence    []Command `yaml:"sequence"`
	KubeContext Context
}

// CommandsConf struct contains the data of the
// commands configuration file
type CommandsConf struct {
	Kind       string `yaml:"kind"`
	ApiVersion string `yaml:"apiVersion"`
	Metadata   struct {
		Name string `yaml:"name"`
	} `yaml:"metadata"`
	Spec struct {
		Aliases []string `yaml:"aliases"`
		Queues  []Queue  `yaml:"queues"`
	}
}

// nodeInfo struct exists only to get the nodes metadata,
// waiting to be expanded
type nodeInfo struct {
	Metadata struct {
		Name string `yaml:"name"`
	} `yaml:"metadata"`
}

// nodeCurrentReplicas struct is an auxiliary struct to
// keep track of the amount of nodes already deployed
type nodeCurrentReplicas struct {
	nodeName     string
	currentIndex int
}

// Node struct contains generic nodes information
type Node struct {
	ConfigName string `yaml:"filename"`
	Count      int    `yaml:"count"`
	name       string
}

// GetName returns the name from metadata of the
// corresponding node
func (node *Node) GetName() (string, error) {
	if node.name == "" {
		return node.inferName()
	} else {
		return node.name, nil
	}
}

// inferName gets the name of the node for the first time
func (node *Node) inferName() (string, error) {
	yamlFile, err := os.ReadFile(node.GetConfName())
	var ni *nodeInfo

	if err != nil {
		return "", err
	}
	err = yaml.Unmarshal(yamlFile, &ni)
	if err != nil {
		return "", err
	}
	if ni == nil {
		return "", errors.New("Missing parameter: 'name' in " + node.GetConfName())
	}
	node.name = ni.Metadata.Name
	return ni.Metadata.Name, nil
}

// GetCurrentIndex fetches the current nodes number from
// the associated node
func (node *Node) GetCurrentIndex(clusterIndex int) int {
	nodeName, _ := node.GetName()
	for i := range nodeCurrentReplicasVec[clusterIndex] {
		if nodeCurrentReplicasVec[clusterIndex][i].nodeName == nodeName {
			return nodeCurrentReplicasVec[clusterIndex][i].currentIndex
		}
	}
	node.SetCurrentIndex(0, clusterIndex)
	return 0
}

// SetCurrentIndex sets the number of nodes deployed from the
// associated node
func (node *Node) SetCurrentIndex(index int, clusterIndex int) {
	nodeName, _ := node.GetName()
	for i := range nodeCurrentReplicasVec[clusterIndex] {
		if nodeCurrentReplicasVec[clusterIndex][i].nodeName == nodeName {
			nodeCurrentReplicasVec[clusterIndex][i].currentIndex = index
			return
		}
	}
	nodeCurrentReplicasVec[clusterIndex] = append(nodeCurrentReplicasVec[clusterIndex], nodeCurrentReplicas{
		nodeName:     nodeName,
		currentIndex: 0,
	})
}

// GetConfName returns the config file name of the
// associated node
func (node *Node) GetConfName() string {
	return node.ConfigName
}

// GetCount returns the replicas wanted for the associated node
func (node *Node) GetCount() int {
	return node.Count
}

// GetClusterNames returns the cluster's name
func GetClusterNames() []string {
	clusterName := make([]string, len(conf.Clusters))
	for i := range conf.Clusters {
		clusterName[i] = conf.Clusters[i].ClusterName
	}
	return clusterName
}

func GetClusterName(clusterIndex int) string {
	if clusterIndex >= len(conf.Clusters) {
		return ""
	}
	return conf.Clusters[clusterIndex].ClusterName
}

func GenKubeConfigPath(cluster string) string {
	homeDir, _ := os.UserHomeDir()
	return path.Join(homeDir, ".kwok", "clusters", cluster, "kubeconfig.yaml")
}

func GetKubeConfigPath(clusterIndex int) string {
	return clusterKubeconfigPaths[clusterIndex]
}

func GetLiqoConsumerCluster() (string, int) {
	return conf.Liqo.Consumer, conf.LiqoConsumerIndex
}

func checkLiqoConsumer() bool {
	for i, cluster := range GetClusterNames() {
		if cluster == conf.Liqo.Consumer {
			conf.LiqoConsumerIndex = i
			return true
		}
	}
	return false
}

func GetLiqoConf() LiqoOpt {
	return conf.Liqo
}

func IsLiqoActive() bool {
	return conf.Liqo.Consumer != ""
}

// GetClusterNameKubeconf returns the cluster's name in the kubeconfig
func GetClusterNameKubeconf() []string {
	res := make([]string, len(conf.Clusters))
	for i := range conf.Clusters {
		res[i] = ClusterKubeconfigs[i].Clusters[0].Name
	}
	return res
}

// GetKwokConf returns the kwok config file name
func GetKwokConf() [][]string {
	kwokConf := make([][]string, len(commandsConf))
	for i := range commandsConf {
		kwokConf[i] = conf.Clusters[i].KwokConfigs
	}
	return kwokConf
}

// GetNodesConf returns a list of Node arranged per cluster
func GetNodesConf() [][]Node {
	var nodes [][]Node
	for i := range commandsConf {
		nodes = append(nodes, conf.Clusters[i].Nodes)
	}
	return nodes
}

// GetAuditConf returns the audit config file name
func GetAuditConf() []string {
	audits := make([]string, len(conf.Clusters))
	for i := range conf.Clusters {
		audits[i] = conf.Clusters[i].Audit
	}
	return audits
}

// GetCommandsConfName returns the name of the commands config file
func GetCommandsConfName() []string {
	if commandsConf == nil {
		return make([]string, 0)
	}
	var confNames = make([]string, len(commandsConf))
	for i := range commandsConf {
		confNames[i] = commandsConf[i].Metadata.Name
	}
	return confNames
}

// GetQueues returns a list of Queue per CommandsConf (per cluster)
func GetQueues() [][]Queue {
	var queues [][]Queue
	for i := range commandsConf {
		queues = append(queues, commandsConf[i].Spec.Queues)
	}
	return queues
}

// IsEmpty returns
//
// true if the associated queue is empty
//
// false otherwise
func (q Queue) IsEmpty() bool { return q.Name == "" }

// GetIndex returns the position in the sequence of the
// associated Command
func (c Command) GetIndex() int { return c.index }

// confPreprocess manages every operation which counts as a
// pre-operation / finalizer for the Config struct
func confPreprocess() {
	for i := range conf.Clusters {
		for j := range conf.Clusters[i].Nodes {
			conf.Clusters[i].Nodes[j].ConfigName = path.Join("configs", "topology", conf.Clusters[i].Nodes[j].ConfigName)
		}
	}

	for i := range commandsConf {
		clusterKubeconfigPaths = append(clusterKubeconfigPaths, GenKubeConfigPath(conf.Clusters[i].ClusterName))
		for j := range commandsConf[i].Spec.Queues {
			if commandsConf[i].Spec.Queues[j].Kubeconfig == "" {
				commandsConf[i].Spec.Queues[j].Kubeconfig = clusterKubeconfigPaths[i]
			}
			for k := range commandsConf[i].Spec.Queues[j].Sequence {
				commandsConf[i].Spec.Queues[j].Sequence[k].index = k + 1
			}
		}
	}
}

// NewConfig is an initializer, it creates the configuration
// struct from the yaml config files
func NewConfig() {
	yamlFile, err := os.ReadFile("configs/config.yaml")

	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	err = yaml.Unmarshal(yamlFile, &conf)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	if conf.Liqo.Consumer != "" {
		checkLiqoConsumer()
	}

	for i := range conf.Clusters {
		yamlFile, err = os.ReadFile(path.Join("configs", "command_configs", conf.Clusters[i].Commands))

		commandsConf = append(commandsConf, &CommandsConf{})
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
		err = yaml.Unmarshal(yamlFile, &commandsConf[i])
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
	}
	confPreprocess()
}

func ConfPostprocess() {
	ClusterKubeconfigs = make([]*KubeConfig, len(conf.Clusters))
	for i := range conf.Clusters {
		yamlFile, err := os.ReadFile(GetKubeConfigPath(i))
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
		err = yaml.Unmarshal(yamlFile, &ClusterKubeconfigs[i])
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
	}

	clusters := GetClusterNameKubeconf()
	nodeCurrentReplicasVec = make([][]nodeCurrentReplicas, len(clusters))

	for i := range commandsConf {
		for j := range commandsConf[i].Spec.Queues {
			currentKubeconf := GenContexts(commandsConf[i].Spec.Queues[j].Kubeconfig, i)
			for k, context := range currentKubeconf.Contexts {
				if clusters[i] == context.ContextInfo.Cluster {
					commandsConf[i].Spec.Queues[j].KubeContext = currentKubeconf.Contexts[k]
					break
				}
			}
			if commandsConf[i].Spec.Queues[j].KubeContext.Name == "" {
				writers.CrashLog("Custom Kubeconfig file does not contain a context with the correct cluster", Some(global.LogCommandInfo{
					CmdIndex:     -1,
					QueueName:    commandsConf[i].Spec.Queues[j].KubeContext.Name,
					ClusterIndex: i,
				}))
			}
			commandsConf[i].Spec.Queues[j].KubeContext.ClusterIndex = i
		}
	}
}

func GenContexts(kubeconf string, clusterIndex int) KubeConfig {

	if kubeconf == clusterKubeconfigPaths[clusterIndex] {
		return *ClusterKubeconfigs[clusterIndex]
	}

	yamlFile, err := os.ReadFile(kubeconf)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	var contexts *KubeConfig
	err = yaml.Unmarshal(yamlFile, &contexts)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	return *contexts
}

package v1alpha1

import (
	"gopkg.in/yaml.v2"
	"main/global"
	. "main/utils"
	"main/writers"
	"os"
	"path"
)

var clusterKubeconfigPaths []string
var ClusterKubeconfigs []*KubeConfig
var none = None[global.LogCommandInfo]()

// KubeConfig struct is to keep track of all the contexts
// from autogenerated and user-provided kubeconfig and their
// associated cluster to switch clusters seamlessly
type KubeConfig struct {
	Contexts []Context     `yaml:"contexts"`
	Clusters []KubeCluster `yaml:"clusters"`
}

type Context struct {
	ContextInfo  ContextInfo `yaml:"context"`
	Name         string      `yaml:"name"`
	ClusterIndex int         `yaml:"-"`
}

type ContextInfo struct {
	Cluster string `yaml:"cluster"`
}

type KubeCluster struct {
	Name string `yaml:"name"`
}

// Kube struct is for wrapped commands who
// want to perform operations through kubectl
type Kube struct {
	Filename string
	Resource string
	Args     []string
	Count    int
}

type Namespace struct {
	Filename string
	Args     []string
}

func GenKubeConfigPath(cluster string) string {
	homeDir, _ := os.UserHomeDir()
	return path.Join(homeDir, ".kwok", "clusters", cluster, "kubeconfig.yaml")
}

func GetKubeConfigPath(clusterIndex int) string {
	return clusterKubeconfigPaths[clusterIndex]
}

// confPreprocess manages every operation which counts as a
// pre-operation / finalizer for the Config struct
func confPreprocess() {
	for i := range conf.Clusters {
		for j := range conf.Clusters[i].Nodes {
			conf.Clusters[i].Nodes[j].Filename = path.Join("configs", "topology", conf.Clusters[i].Nodes[j].Filename)
		}
	}

	for i := range commandsConf {
		clusterKubeconfigPaths = append(clusterKubeconfigPaths, GenKubeConfigPath(conf.Clusters[i].ClusterName))
		for j := range commandsConf[i].Spec.Queues {
			if commandsConf[i].Spec.Queues[j].Kubeconfig == "" {
				commandsConf[i].Spec.Queues[j].Kubeconfig = clusterKubeconfigPaths[i]
			}
			for k := range commandsConf[i].Spec.Queues[j].Sequence {
				commandsConf[i].Spec.Queues[j].Sequence[k].index = k + 1
			}
		}
	}
}

// NewConfig is an initializer, it creates the configuration
// struct from the yaml config files
func NewConfig() {
	yamlFile, err := os.ReadFile("configs/config.yaml")

	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	err = yaml.Unmarshal(yamlFile, &conf)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	if conf.Liqo.Consumer != "" {
		checkLiqoConsumer()
	}

	for i := range conf.Clusters {
		yamlFile, err = os.ReadFile(path.Join("configs", "command_configs", conf.Clusters[i].Commands))

		commandsConf = append(commandsConf, &CommandsConf{})
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
		err = yaml.Unmarshal(yamlFile, &commandsConf[i])
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
	}
	confPreprocess()
}

func ConfPostprocess() {
	ClusterKubeconfigs = make([]*KubeConfig, len(conf.Clusters))
	for i := range conf.Clusters {
		yamlFile, err := os.ReadFile(GetKubeConfigPath(i))
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
		err = yaml.Unmarshal(yamlFile, &ClusterKubeconfigs[i])
		if err != nil {
			writers.CrashLog(err.Error(), none)
		}
		ClusterKubeconfigs[i].Contexts[0].ClusterIndex = i
	}

	clusters := GetClusterNameKubeconf()
	nodeCurrentReplicasVec = make([][]nodeCurrentReplicas, len(clusters))

	for i := range commandsConf {
		for j := range commandsConf[i].Spec.Queues {
			currentKubeconf := GenContexts(commandsConf[i].Spec.Queues[j].Kubeconfig, i)
			for k, context := range currentKubeconf.Contexts {
				if clusters[i] == context.ContextInfo.Cluster {
					commandsConf[i].Spec.Queues[j].KubeContext = currentKubeconf.Contexts[k]
					break
				}
			}
			if commandsConf[i].Spec.Queues[j].KubeContext.Name == "" {
				writers.CrashLog("Custom Kubeconfig file does not contain a context with the correct cluster", Some(global.LogCommandInfo{
					CmdIndex:     -1,
					QueueName:    commandsConf[i].Spec.Queues[j].KubeContext.Name,
					ClusterIndex: i,
				}))
			}
			commandsConf[i].Spec.Queues[j].KubeContext.ClusterIndex = i
		}
	}
}

func GenContexts(kubeconf string, clusterIndex int) KubeConfig {

	if kubeconf == clusterKubeconfigPaths[clusterIndex] {
		return *ClusterKubeconfigs[clusterIndex]
	}

	yamlFile, err := os.ReadFile(kubeconf)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	var contexts *KubeConfig
	err = yaml.Unmarshal(yamlFile, &contexts)
	if err != nil {
		writers.CrashLog(err.Error(), none)
	}
	return *contexts
}
